# A0118005W
###### src\date\DatePair.java
``` java
public class DatePair {
	private Date _startDate = null;
	private Date _endDate = null;
	private String _dateString = null;
	private String _errorMsg = null;
	private boolean _isError = false;
	
	public DatePair(Date startDate, Date endDate) {
		_startDate = startDate;
		_endDate = endDate;
	}
	
	public Date getStartDate() {
		return _startDate;
	}
	
	public Date getEndDate() {
		return _endDate;
	}
	
	public void setDateString(String dateString) {
		_dateString = dateString;
	}
	
	public String getDateString() {
		return _dateString;
	}
	
	public void setErrorMsg(String msg) {
		_isError = true;
		_errorMsg = msg;
	}
	
	public boolean isError() {
		return _isError;
	}
	
	public String getErrorMsg() {
		return _errorMsg;
	}
}
```
###### src\date\DateTime.java
``` java
public class DateTime extends DateTimeHelper {
	private static final int DAY = 0;
	private static final int MONTH = 1;
	private static final int YEAR = 2;
	private static final int DATE_SIZE = 3;
	private static final int DAY_MONTH_SIZE = 2;
	private static final int DAY_MONTH_YEAR_SIZE = 3;
	private static final String JOIN_DELIMITER = "-";
	
	private static final String SHORT_MONTH = "jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec";
	private static final String LONG_MONTH = "january|february|march|april|may|june|"
			+ "july|august|september|october|november|december";
	private static final String MONTH_REGEX = SHORT_MONTH + "|" + LONG_MONTH;
	
	private static final Parser dateParser = new Parser();
	private static final int _flags = Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE;
	private static final HashMap<MonthType, Integer> months = new HashMap<MonthType, Integer>();
	private static final Logger logger = Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);
	
	static {
		months.clear();
		
		months.put(MonthType.JAN, 1);
		months.put(MonthType.JANUARY, 1);
		
		months.put(MonthType.FEB, 2);
		months.put(MonthType.FEBRUARY, 2);
		
		months.put(MonthType.MAR, 3);
		months.put(MonthType.MARCH, 3);
		
		months.put(MonthType.APR, 4);
		months.put(MonthType.APRIL, 4);
		
		months.put(MonthType.MAY, 5);
		
		months.put(MonthType.JUN, 6);
		months.put(MonthType.JUNE, 6);
		
		months.put(MonthType.JUL, 7);
		months.put(MonthType.JULY, 7);
		
		months.put(MonthType.AUG, 8);
		months.put(MonthType.AUGUST, 8);
		
		months.put(MonthType.SEP, 9);
		months.put(MonthType.SEPTEMBER, 9);
		
		months.put(MonthType.OCT, 10);
		months.put(MonthType.OCTOBER, 10);
		
		months.put(MonthType.NOV, 11);
		months.put(MonthType.NOVEMBER, 11);
		
		months.put(MonthType.DEC, 12);
		months.put(MonthType.DECEMBER, 12);
	}

	/**
	 * Parse the date with the given input.
	 * @param input - text
	 * @return date, exact date string and error message
	 */
	public static ParsedDate parse(String input) {
		ParsedDate result = new ParsedDate();
		try {
			String dateStr = getDate(input);
			String timeStr = getTime(input);
			String parsedStr = input;
			Date date = null;
			
			if (dateStr != null) {
				if (timeStr != null) {
					dateStr += " " + timeStr;
				}
				parsedStr = dateStr;
			}
			date = dateParser.parse(parsedStr).get(0).getDates().get(0);
			dateStr = dateParser.parse(input).get(0).getText();
			
			if (date != null) {
				boolean isAbsolute = isAbsoluteDate(parsedStr);
				boolean isValid = isValidDate(parsedStr);
				result = new ParsedDate(date, isValid, isAbsolute);
				result.setDateString(dateStr);
			}

		} catch (Exception e) {
			return new ParsedDate();
		}
		return result;
	}
	
	/**
	 * Get the time from the input string.
	 * @param input - possible time string
	 * @return time string if the pattern is matched
	 */
	public static String getTime(String input) {
		String regexAmPm = ".*?([0-9]{1,2})\\s?(am|pm).*";
		String regexAmPm2 = ".*?([0-9]{1,2})[:.]([0-9]{1,2})\\s?(am|pm).*";
		String regexColon = ".*?([0-9]{1,2})[:.]([0-9]{1,2}).*";
		
		Pattern pattern = Pattern.compile(regexAmPm, _flags);
		Matcher matcher = pattern.matcher(input);
		
		if (matcher.matches()) {
			if(isValidTime(matcher.group(1), null)) {
				return matcher.group(1) + matcher.group(2);
			}
		}
		
		pattern = Pattern.compile(regexAmPm2);
		matcher = pattern.matcher(input);
		
		if (matcher.matches()) {
			if(isValidTime(matcher.group(1), matcher.group(2))) {
				return matcher.group(1) + ":" + matcher.group(2) + matcher.group(3);
			}
		}
		
		pattern = Pattern.compile(regexColon);
		matcher = pattern.matcher(input);
		
		if (matcher.matches()) {
			if(isValidTime(matcher.group(1), matcher.group(2))) {
				return matcher.group(1) + ":" + matcher.group(2);
			}
		}
		return null;
	}
	
	/**
	 * Get the date from the input string.
	 * @param input - possible date string
	 * @return date string if the pattern is matched
	 */
	private static String getDate(String input) {
		String regexTextMD1 = ".*?(" + MONTH_REGEX + ")[ /-]([0-9]{1,2})\\s.*";
		String regexTextMD2 = ".*?(" + MONTH_REGEX + ")[ /-]([0-9]{1,2})";
		String regexTextMDY1 = ".*?(" + MONTH_REGEX + ")[ /-]([0-9]{1,2})[ ,/-]\\s?([0-9]{2,4})\\s.*";
		String regexTextMDY2 = ".*?(" + MONTH_REGEX + ")[ /-]([0-9]{1,2})[ ,/-]\\s?([0-9]{2,4})";
		String[] allRegex = {regexTextMD1, regexTextMD2, regexTextMDY1, regexTextMDY2};
		
		String date = getAmericanDate(input);
		
		if (date == null) {
			for (int i = 0; i < allRegex.length; i++) {
				String regex = allRegex[i];
				Pattern pattern = Pattern.compile(regex, _flags);
				Matcher matcher = pattern.matcher(input);
				
				if (matcher.matches()) {
					int groupNum = matcher.groupCount();
					ArrayList<String> words = new ArrayList<String>();
					
					for (int j = 1; j <= groupNum; j++) {
						String word = matcher.group(j);
						
						if (j == 1 && !isConvertable(word)) {
							word = months.get(MonthType.toMonth(word)).toString();
						}
						words.add(word);
					}
					date = String.join(JOIN_DELIMITER, words);
				}
			}
		}
		
		return date;
	}
	
	/**
	 * Check if the given string contains absolute date 
	 * (which includes year).
	 * @param input - date string
	 * @return true if it contains year; false otherwise
	 */
	private static boolean isAbsoluteDate(String input) {
		if (input == null) {
			return false;
		}
		
		Pattern pattern = Pattern.compile("([0-9]{1,2})-([0-9]{1,2})-([0-9]{2,4})", _flags);
		Matcher matcher = pattern.matcher(input);
		
		return matcher.matches();
	}
	
	/**
	 * Check if the date is valid.
	 * @param input - date string
	 * @return true if the date is valid; false otherwise
	 */
	private static boolean isValidDate(String input) {
		if (input == null) {
			return false;
		}
		
		String[] formats = {"MM-dd-yyyy", "MM-dd"};
		SimpleDateFormat dateFormat = new SimpleDateFormat();
		boolean isDate = false;
		
		Pattern pattern1 = Pattern.compile("([0-9]{1,2})-([0-9]{1,2})-([0-9]{2,4})", _flags);
		Matcher matcher1 = pattern1.matcher(input);
		
		Pattern pattern2 = Pattern.compile("([0-9]{1,2})-([0-9]{1,2})", _flags);
		Matcher matcher2 = pattern2.matcher(input);
		
		isDate = matcher1.matches() || matcher2.matches();
		
		if (!isDate) {
			return true;
		}
		
		for (int i = 0; i < formats.length; i++) {
			try {
				dateFormat = new SimpleDateFormat(formats[i]);
				dateFormat.setLenient(false);
				dateFormat.parse(input);
				return true;
			} catch (ParseException e) {}
		}
		return false;
	}
	
	/**
	 * Check if the time is valid.
	 * @param hourStr - hour string
	 * @param minStr - minute string
	 * @return true if the time is valid
	 */
	private static boolean isValidTime(String hourStr, String minStr) {
		try {
			int hour = Integer.parseInt(hourStr);
			
			if (hour > 23) {
				return false;
			}
			
			if (minStr != null) {
				int min = Integer.parseInt(minStr);
				if (min > 59) {
					return false;
				}
			}
			
		} catch (Exception e) {
			return false;
		}
		return true;
	}

	/**
	 * Convert the British date format into American date format, "MMM DD YYYY" or "MMM DD YY".
	 * @param input - possible British date format input
	 * @return standard date format
	 */
	private static String getAmericanDate(String input) {
		String regexNumbericDM = ".*?([0-9]{1,2})[/-]([0-9]{1,2}).*";
		String regexTextDM1 = ".*?([0-9]{1,2})[ /-](" + MONTH_REGEX + ")\\s.*";
		String regexTextDM2 = ".*?([0-9]{1,2})[ /-](" + MONTH_REGEX + ")";
		String regexNumericDMY = ".*?([0-9]{1,2})[/-]([0-9]{1,2})[/-]([0-9]{2,4}).*";
		String regexTextDMY1 = ".*?([0-9]{1,2})[ /-](" + MONTH_REGEX + ")[ ,/-]\\s?([0-9]{2,4})\\s.*";
		String regexTextDMY2 = ".*?([0-9]{1,2})[ /-](" + MONTH_REGEX + ")[ ,/-]\\s?([0-9]{2,4})";
				
		String[] twoGroups = {regexNumbericDM, regexTextDM1, regexTextDM2 };
		String[] threeGroups = {regexNumericDMY, regexTextDMY1, regexTextDMY2};
		
		for (int i = 0; i < threeGroups.length; i++) {
			String result = getDateMatcher(input, threeGroups[i], DAY_MONTH_YEAR_SIZE);
			
			if (result != null) {
				return result;
			}
		}
	
		for (int i = 0 ; i< twoGroups.length; i++) {
			String result = getDateMatcher(input, twoGroups[i], DAY_MONTH_SIZE);
			
			if (result != null) {
				return result;
			}
		}
		return null;
	}

	/**
	 * Get the string that contains the date format.
	 * @param input - possible date string
	 * @param regex - regular expression to determine the date
	 * @param groupNumber - number of groups in the regular expression
	 * @return string contains date
	 */
	private static String getDateMatcher(String input, String regex, int groupNumber) {
		String dateTime = null;
		String[] dayMonthYear = new String[DATE_SIZE];
		Arrays.fill(dayMonthYear, "");

		Pattern pattern = Pattern.compile(regex, _flags);
		Matcher matcher = pattern.matcher(input);

		if (matcher.matches()) {
			dateTime = "";
			for (int i = 0; i < groupNumber; i++) {
				dayMonthYear[i] = matcher.group(i + 1);
			}

			if (groupNumber >= DAY_MONTH_SIZE) {
				String monthStr = dayMonthYear[MONTH].toLowerCase();
				if (!isConvertable(monthStr)) {
					MonthType month = MonthType.toMonth(monthStr);
					if(months.containsKey(month)) {
						dayMonthYear[MONTH] = months.get(month).toString();
					}
				}
				
				dateTime += dayMonthYear[MONTH] + JOIN_DELIMITER;
				dateTime += dayMonthYear[DAY];
			}

			if (groupNumber == DAY_MONTH_YEAR_SIZE) {
				dateTime += JOIN_DELIMITER + dayMonthYear[YEAR];
			}
		}

		return dateTime;
	}
	
	/**
	 * Check if the input is able to convert to integer.
	 * @param number - number string
	 * @return true if it is convertible; false otherwise
	 */
	private static boolean isConvertable(String number) {
		try {
			Integer.parseInt(number);
		} catch (NumberFormatException e) {
			logger.info("Month format was MMM or month.");
			return false;
		}
		return true;
	}
}
```
###### src\date\DateTimeHelper.java
``` java
public class DateTimeHelper {
	
	/**
	 * Get one year later from the given date.
	 * @param date
	 * @return date that is one year later
	 */
	public static Date getOneWeekLater(Date date) {
		if (date != null) {
			Calendar calendar = Calendar.getInstance();
			calendar.setTime(date);
			
			calendar.add(Calendar.DAY_OF_MONTH, 7);
			date = calendar.getTime();
		}
		return date;
	}
	
	/**
	 * Get one week later from the given date.
	 * @param date
	 * @return date that is one week later
	 */
	public static Date getOneYearLater(Date date) {
		if (date != null) {
			Calendar calendar = Calendar.getInstance();
			calendar.setTime(date);
			
			calendar.add(Calendar.YEAR, 1);
			date = calendar.getTime();
		}
		return date;
	}
	
	/**
	 * Get today's date with the time of 23:59.
	 * @return today's date
	 */
	public static Date getToday() {
		Calendar todayCalendar = Calendar.getInstance();
		
		// Initialize today
		todayCalendar.set(Calendar.HOUR_OF_DAY, 23);
		todayCalendar.set(Calendar.MINUTE, 59);
		todayCalendar.set(Calendar.SECOND, 59);
		
		return todayCalendar.getTime();
	}
	
	/**
	 * Combine the date and time into a standard date format.
	 * @param date 
	 * @param time
	 * @return standard date format
	 */
	public static Date combineDateTime(Date date, Date time) {
		if (date != null && time != null) {
			Calendar calendar = Calendar.getInstance();
			Calendar dateCalendar = Calendar.getInstance();
			Calendar timeCalendar = Calendar.getInstance();

			calendar.clear();
			dateCalendar.setTime(date);
			timeCalendar.setTime(time);

			calendar.set(Calendar.YEAR, dateCalendar.get(Calendar.YEAR));
			calendar.set(Calendar.MONTH, dateCalendar.get(Calendar.MONTH));
			calendar.set(Calendar.DATE, dateCalendar.get(Calendar.DATE));
			calendar.set(Calendar.HOUR_OF_DAY, timeCalendar.get(Calendar.HOUR_OF_DAY));
			calendar.set(Calendar.MINUTE, timeCalendar.get(Calendar.MINUTE));
			calendar.set(Calendar.SECOND, timeCalendar.get(Calendar.SECOND));

			return calendar.getTime();
		}
		return null;
	}
}
```
###### src\date\ParsedDate.java
``` java
public class ParsedDate {
	private Date _date;
	private boolean _isValid;
	private boolean _isAbsolute;
	private String _dateString = null;
	
	public ParsedDate() {
		_date = null;
		_isValid = false;
		_isAbsolute = false;
	}
	
	public ParsedDate(Date date, boolean isValid, boolean isAbsolute) {
		_date = date;
		_isValid = isValid;
		_isAbsolute = isAbsolute;
	}
	
	public Date getDate() {
		return _date;
	}
	
	public boolean isValid() {
		if (_date == null) {
			return true;
		}
		return _isValid;
	}
	
	public boolean isAbsolute() {
		return _isAbsolute;
	}
	
	public void setDateString(String dateString) {
		_dateString = dateString;
	}
	
	public String getDateString() {
		return _dateString;
	}
	
}
```
###### src\gui\UITextField.java
``` java
public class UITextField extends InlineCssTextArea {
	private static ArrayList<Task> _displayList = new ArrayList<Task>();
	private ContextMenu popupMenu = new ContextMenu();
	
	public UITextField() {
		super();
		setAutoFill();
	}
	
	/**
	 * Update the display list in TextField.
	 * @param displayList - display list
	 */
	public void updateDisplayList(ArrayList<Task> displayList) {
		_displayList = displayList;
	}
	
	/**
	 * Show pop-up menu.
	 */
	public void showPopup() {
		if (!popupMenu.isShowing()) {
			popupMenu.show(this, Side.BOTTOM, 0, 0);
		}
	}
	
	/**
	 * Set up auto fill in of the text field.
	 */
	private void setAutoFill() {
		this.textProperty().addListener(new ChangeListener<String>() {

			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				String text = UITextField.this.getText();
				String[] textTokens = text.split(" ");
				
				popupMenu.hide();
				
				int spaceCount = 0;
				for (int i = 0; i < text.length() && spaceCount < 2; i++) {
					if (text.charAt(i) == ' ') {
						spaceCount += 1;
					}
				}
				
				if (textTokens.length == 2 && spaceCount == 2) {
					String firstToken = textTokens[0];
					CommandType cmd = CommandType.toCmd(firstToken);
					int index = getInteger(textTokens[1]) - 1;
					boolean isWithinRange = ((index >= 0) && (index < _displayList.size()));
					
					if (cmd == CommandType.EDIT && isWithinRange) {
						Task task = _displayList.get(index);
						populatePopup(index, task);
						
						if (!popupMenu.isShowing()) {
							popupMenu.show(UITextField.this, Side.BOTTOM, 0, 0);
						}	
					} 
				} else if (textTokens.length <= 2){
					// Hide pop up
					popupMenu.hide();
					popupMenu.getItems().clear();
				}
				
			}
			
		});
	}
	
	/**
	 * Get the integer from an input string.
	 * If the input cannot be parsed, return -1.
	 * @param input - input string
	 * @return parsed integer
	 */
	private int getInteger(String input) {
		try {
			int integer = Integer.parseInt(input);
			return integer;
		} catch (NumberFormatException e) {
			return -1;
		}
	}
	
	/**
	 * Populate the pop-up box.
	 * @param index - index of the task
	 * @param task - task to be displayed
	 */
	private void populatePopup(int index, Task task) {
		ArrayList<String> displayList = getDisplayItems(index, task);
		ArrayList<CustomMenuItem> menuItems = new ArrayList<CustomMenuItem>();
		
		for (int i = 0; i < displayList.size(); i++) {
			String str = displayList.get(i);
			Label label = new Label(str);
			CustomMenuItem item = new CustomMenuItem(label, true);

			item.setOnAction(new EventHandler<ActionEvent>() {

				@Override
				public void handle(ActionEvent event) {
					replaceText(str);
					positionCaret(str.length());
				}

			});

			menuItems.add(item);
		}
		
		popupMenu.getItems().clear();
		popupMenu.getItems().addAll(menuItems);
	}
	
	/**
	 * Get the command input to be displayed in the pop-up menu.
	 * @param index - index of the task
	 * @param task - task to be displayed
	 * @return display items
	 */
	private ArrayList<String> getDisplayItems(int index, Task task) {
		ArrayList<String> items = new ArrayList<String>();
		TaskType taskType = task.getTaskType();
		
		Integer displayIndex = index + 1;
		String floatingStr = "edit " + displayIndex.toString() + " " + task.getTaskName() + " ";
		String eventStr = floatingStr;
		String alternateEventStr = floatingStr;
		String deadlineStr = floatingStr;
		
		Calendar tmrCalendar = Calendar.getInstance();
		Calendar afterTmrCalendar = Calendar.getInstance();
		tmrCalendar.add(Calendar.DAY_OF_MONTH, 1);	
		afterTmrCalendar.add(Calendar.DAY_OF_MONTH, 2);
		
		Date tomorrow = tmrCalendar.getTime();
		Date afterTomorrow = afterTmrCalendar.getTime();
		Date startDate = task.getStartDate();
		Date endDate = task.getEndDate();
		
		SimpleDateFormat dateFormat = new SimpleDateFormat("dd-MM-yyyy HH:mm");
		
		// Set event string
		if (startDate != null && endDate != null) {
			eventStr += "from " + dateFormat.format(startDate) + " ";
			eventStr += "to " + dateFormat.format(endDate);
			
			alternateEventStr += "on " + dateFormat.format(startDate);
		} else if (startDate != null) {
			Calendar calendar = Calendar.getInstance();
			calendar.setTime(startDate);
			calendar.add(Calendar.DAY_OF_MONTH, 1);	
			
			eventStr += "on " + dateFormat.format(startDate);
			
			alternateEventStr += "from " + dateFormat.format(startDate) + " ";
			alternateEventStr += "to " + dateFormat.format(calendar.getTime());
		} else if (endDate != null) {
			Calendar calendar = Calendar.getInstance();
			calendar.setTime(endDate);
			calendar.add(Calendar.DAY_OF_MONTH, 1);
			
			eventStr += "from " + dateFormat.format(endDate) + " ";
			eventStr += "to " + dateFormat.format(calendar.getTime());
			
			alternateEventStr += "on " + dateFormat.format(endDate);
			
		} else {
			eventStr += "from " + dateFormat.format(tomorrow) + " ";
			eventStr += "to " + dateFormat.format(afterTomorrow);
			
			alternateEventStr += "on " + dateFormat.format(tomorrow);
		}
		
		// Set deadline string
		if (endDate != null) {
			deadlineStr += "by " + dateFormat.format(endDate);
		} else if (startDate != null) {
			deadlineStr += "by " + dateFormat.format(startDate);
		} else {
			deadlineStr += "by " + dateFormat.format(tomorrow);
		}
		
		// Assign display order
		int eventIndex = 0;
		int floatingIndex = 1;
		int alternateEventIndex = 2;
		int deadlineIndex = 3;
		int firstIndex = -1;
		
		String[] eventList = {eventStr, floatingStr, alternateEventStr, deadlineStr};
		
		switch (taskType) {
			case EVENT:
				if (endDate == null) {
					items.add(eventList[alternateEventIndex]);
					firstIndex = alternateEventIndex;
				} else {
					items.add(eventList[eventIndex]);
					firstIndex = eventIndex;
				}
				break;
			case DEADLINE:
				items.add(eventList[deadlineIndex]);
				firstIndex = deadlineIndex;
				break;
			case FLOATING:
				items.add(eventList[floatingIndex]);
				firstIndex = floatingIndex;
				break;
			default:
				// Do nothing
		}
		
		for (int i = 0; i < eventList.length; i++) {
			if (i != firstIndex) {
				items.add(eventList[i]);
			}
		}
		
		return items;
	}
}
```
###### src\history\History.java
``` java
public class History {
	
	private static final Logger logger = Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);
	
	private static Stack<ExecutionPair> _undoStack = new Stack<ExecutionPair>();
	private static Stack<ExecutionPair> _redoStack = new Stack<ExecutionPair>();
	
	/**
	 * Push for ADD, DELETE, DONE and UNDONE functions.
	 * @param cmd - command type
	 * @param task - saved task
	 * @return true if it is pushed successful; false otherwise
	 */
	public static boolean push(CommandType cmd, Task task) {
		try {
			ExecutionPair pair = new ExecutionPair(cmd, task, task);
			_undoStack.push(pair);
			_redoStack.clear();
		} catch (Exception e) {
			logger.info("Unsuccessful pushing for command Add, Delete, Done and Undone.");
			return false;
		}
		return true;
	}
	
	/**
	 * Push for EDIT function.
	 * @param cmd - command type
	 * @param oldTask - task before execution
	 * @param newTask - task after execution
	 * @return true if it is pushed successful; false otherwise
	 */
	public static boolean push(CommandType cmd, Task befExeTask, Task aftExeTask) {
		try {
			ExecutionPair pair = new ExecutionPair(cmd, befExeTask, aftExeTask);
			_undoStack.push(pair);
			_redoStack.clear();
		} catch (Exception e) {
			logger.info("Unsuccessful pushing for command Edit.");
			return false;
		}
		return true;
	}
	
	/**
	 * Push non-editable functions.
	 * @param cmd - command type
	 * @param content - content of the input
	 * @return true if it is pushed successful; false otherwise
	 */
	public static boolean push(CommandType cmd, String content) {
		try {
			ExecutionPair pair = new ExecutionPair(cmd, content);
			_undoStack.push(pair);
			_redoStack.clear();
		} catch (Exception e) {
			logger.info("Unsucessful pushing for non-editable functions.");
			return false;
		}
		return true;
	}
	
	/**
	 * Get parsing result for undo.
	 * Return null if there is no more undo operation.
	 * @return undo result
	 */
	public static Result undo() {
		try {
			ExecutionPair pair = _undoStack.pop();
			Result result = pair.getUndo();
			_redoStack.push(pair);
			
			// Get undo again if the command type is not editable
			if (!isEditableType(result.getCommand())) {
				pair = _undoStack.pop();
				result = pair.getUndo();
				_redoStack.push(pair);
			}
			
			return result;
		} catch (EmptyStackException e) {
			logger.info("Stack for undo operation is empty.");
			return null;
		}
	}
	
	/**
	 * Get parsing result for redo.
	 * Return null if there is no more redo operation.
	 * @return redo result
	 */
	public static Result redo() {
		try {
			ExecutionPair pair = _redoStack.pop();
			_undoStack.push(pair);
			return pair.getRedo();
		} catch (EmptyStackException e) {
			logger.info("Stack for redo operation is empty.");
			return null;
		}
	}
	
	/**
	 * Determine if the command type is editable.
	 * @param cmd - command type
	 * @return true if command is editable type; false otherwise
	 */
	private static boolean isEditableType(CommandType cmd) {
		return cmd == CommandType.ADD ||
				cmd == CommandType.DELETE ||
				cmd == CommandType.EDIT ||
				cmd == CommandType.DONE ||
				cmd == CommandType.UNDONE;
	}
}
```
###### src\logic\LogicController.java
``` java
public class LogicController {
	private static final String ERROR_NO_UNDO = "Feedback: No undo operation!";
	private static final String ERROR_NO_REDO = "Feedback: No redo operation!";
	
	//private static final int NON_FLOATING_DISPLAY_SIZE = 5;
	private static CommandType _currentCmd = CommandType.INVALID;
	private static int _nonFloatingDisplaySize = 5;
	
	private static ArrayList<Task> _displayList = 
			new ArrayList<Task>();
	private static ConcurrentSkipListMap<Integer, Task> _taskList =
			new ConcurrentSkipListMap<Integer, Task>();
	/**
	 * Initialize logic class.
	 */
	static {
		_taskList = Storage.readTasks();
		_displayList = new ArrayList<Task>(_taskList.values());
		_displayList = setDisplayList(false);
	}
	
	/**
	 * Process the command.
	 * @param input - command to be executed
	 * @param displayList - task list that is being displayed
	 * @return feedback message
	 */
	public static String process(String input, ArrayList<Task> displayList) {
		// Set up the parsing result
		Result result = Parser.parse(input, displayList);
		CommandType cmd = result.getCommand();
		Task befExeTask = null;
		int resultStorageID = result.getStorageID();
		String message = null;
		
		if (result.isError()) {
			message = result.getErrorMsg();
		} else {
			if (result.getStorageID() != -1) {
				befExeTask = _taskList.get(resultStorageID);
			}

			// Execute parsing result
			Feedback feedback = execute(result);
			message = feedback.getMessage();

			// Initialize current command
			_currentCmd = CommandType.INVALID;

			// Store successful execution
			if (feedback.isSuccessful()) {
				_currentCmd = result.getCommand();
				Task aftExeTask = _taskList.get(resultStorageID);
				recordExecution(cmd, result.getContent(), befExeTask, aftExeTask);
			}
		}
		
		return message;
	}
	
	/**
	 * Undo the previous operations.
	 * @return feedback message
	 */
	public static String undo() {
		Result result = History.undo();
		if (result != null) {
			Feedback feedback = execute(result);
			return feedback.getMessage();
		} else {
			return ERROR_NO_UNDO;
		}
	}
	
	/**
	 * Redo the operations.
	 * @return feedback message
	 */
	public static String redo() {
		Result result = History.redo();
		if (result != null) {
			Feedback feedback = execute(result);
			return feedback.getMessage();
		} else {
			return ERROR_NO_REDO;
		}
	}
	
	/**
	 * Execute the input according to the parsing result.
	 * @param result - parsing result
	 * @return feedback
	 */
	private static Feedback execute(Result result) {
		ICommand command = ICommand.getCommand(result, _taskList);
		Feedback feedback = command.execute();
		
		_taskList = feedback.getUpdatedTaskList();
		_displayList = feedback.getDisplayList();
		_displayList = setDisplayList(result.getCommand() == CommandType.SHOW);
		return feedback;
	}

	/**
	 * Record the execution for undo and redo purposes
	 * @param cmd - command type
	 * @param content - content of the input
	 * @param befExeTask - task before execution
	 * @param aftExeTask - task after execution
	 */
	private static void recordExecution(CommandType cmd, String content,
			Task befExeTask, Task aftExeTask) {
		switch(cmd) {
			case ADD:
				int index = _taskList.lastKey();
				Task newTask = _taskList.get(index);
				History.push(cmd, newTask);
				break;
			case DELETE:
				History.push(cmd, befExeTask);
				break;
			case EDIT:
				History.push(cmd, befExeTask, aftExeTask);
				break;
			case DONE: case UNDONE:
				History.push(cmd, aftExeTask);
				break;
			default:
				History.push(cmd, content);
		}
	}
	
	/**
	 * Remove done task(s) for display purpose except for command "show".
	 * @param isShowCommand - true if the command is "show"; false otherwise
	 * @return display task list
	 */
	private static ArrayList<Task> setDisplayList(boolean isShowCommand) {
		ArrayList<Task> displayList = new ArrayList<Task>();
		if (isShowCommand) {
			displayList = _displayList;
		} else {
			for (int i = 0; i < _displayList.size(); i++) {
				Task task = _displayList.get(i);
				if (!task.getCompleted()) {
					displayList.add(task);
				}
			}
		}
		return displayList;
	}
	
	/**
	 * Get the task list in ConcurrentSkipListMap<Integer, Task> form.
	 * @return tasklist
	 */
	public static ConcurrentSkipListMap<Integer, Task> getTaskList() {
		return _taskList;
	}
	
	/**
	 * Get the task list for display.
	 * @return display task list
	 */
	public static ArrayList<Task> getDisplayList() {
		Collections.sort(_displayList, taskComparator);
		return _displayList;
	}
	
	/**
	 * Get the floating task list for display.
	 * @return display floating task list
	 */
	public static ArrayList<Task> getFloatingList() {
		ArrayList<Task> floatingList = new ArrayList<Task>();
		
		for (int i = 0; i < _displayList.size(); i++) {
			Task task = _displayList.get(i);
			if (task.getTaskType() == TaskType.FLOATING) {
				floatingList.add(task);
			}
		}
		return floatingList;
	}
	
	/**
	 * Get the non-floating task list for display.
	 * @return display non-floating task list
	 */
	public static ArrayList<Task> getNonFloatingList() {
		ArrayList<Task> nonFloatingList = new ArrayList<Task>();
		
		for (int i = 0; i < _displayList.size(); i++) {
			Task task = _displayList.get(i);
			if (task.getTaskType() != TaskType.FLOATING) {
				nonFloatingList.add(task);
			}
		}
		
		Collections.sort(nonFloatingList, taskComparator);
		
		// Show today's tasks.
		// If today's tasks are fewer than 5, add up to 5 tasks.
		if (_currentCmd != CommandType.SHOW) {
			ArrayList<Task>	displayList = new ArrayList<Task>();
			Date today = DateTime.getToday();
			
			for (Task task: nonFloatingList) {
				Date startDate = task.getStartDate();
				Date endDate = task.getEndDate();
				int displaySize = displayList.size();
				boolean isAdded = false;
				
				if (startDate != null) {		// Compare start date
					if (startDate.compareTo(today) <= 0) {
						displayList.add(task);
						isAdded = true;
					}
				} else if (endDate != null) {	// Compare end date
					if (endDate.compareTo(today) <= 0) {
						displayList.add(task);
						isAdded = true;
					}
				} 
				
				if (!isAdded) {
					if (displaySize < _nonFloatingDisplaySize) {
						displayList.add(task);
					} else {
						break;
					}
				}
			}
			
			return displayList;
		} 
		
		return nonFloatingList;
	}
	
	public static void setNonFloatingDisplaySize(int size) {
		_nonFloatingDisplaySize = size;
	}
	
```
###### src\object\ExecutionPair.java
``` java
public class ExecutionPair {
	private CommandType _cmd = CommandType.INVALID;
	private String _content = null;
	private Task _befExeTask = null;
	private Task _aftExeTask = null;
	
	/**
	 * Constructor for editable command type.
	 * For example, ADD, DELETE, EDIT, DONE and UNDONE.
	 * @param cmd - editable command type
	 * @param befExeTask - task before execution
	 * @param aftExeTask - task after execution
	 */
	public ExecutionPair(CommandType cmd, Task befExeTask, Task aftExeTask) {
		_cmd = cmd;
		_befExeTask = befExeTask;
		_aftExeTask = aftExeTask;
	}
	
	/**
	 * Constructor for non-editable command type.
	 * For example, SEARCH, SHOW, HELP AND HOME.
	 * @param cmd - non-editable command type
	 * @param content - content of the parsing result
	 */
	public ExecutionPair(CommandType cmd, String content) {
		_cmd = cmd;
		_content = content;
	}
	
	/**
	 * Get undo execution result.
	 * @return undo result
	 */
	public Result getUndo() {
		CommandType newCmd = getReverseCmd();
		if (isEditableType(newCmd)) {
			return new Result(newCmd, _befExeTask);
		} else {
			Result result = new Result();
			result.setCommand(newCmd);
			result.setContent(_content);
			return result;
		}
	}
	
	/**
	 * Get redo execution result.
	 * @return redo result
	 */
	public Result getRedo() {
		if (isEditableType(_cmd)) {
			return new Result(_cmd, _aftExeTask);
		} else {
			Result result = new Result();
			result.setCommand(_cmd);
			result.setContent(_content);
			return result;
		}
	}
	
	/**
	 * Determine if the command type is editable.
	 * @param cmd - command type
	 * @return true if command is editable type; false otherwise
	 */
	private boolean isEditableType(CommandType cmd) {
		return cmd == CommandType.ADD ||
				cmd == CommandType.DELETE ||
				cmd == CommandType.EDIT ||
				cmd == CommandType.DONE ||
				cmd == CommandType.UNDONE;
	}
	
	/**
	 * Get the reverse of the command type.
	 * For example, ADD <-> DELETE, DONE <-> UNDONE
	 * @return reverse command type
	 */
	private CommandType getReverseCmd() {
		switch (_cmd) {
			case ADD:
				return CommandType.DELETE;
			case DELETE:
				return CommandType.ADD;
			case DONE:
				return CommandType.UNDONE;
			case UNDONE:
				return CommandType.DONE;
			default:
				return _cmd;
		}
	}
}
```
###### src\object\Result.java
``` java
public class Result {
	private int _storageID = -1;
	private CommandType _cmd = null;
	private TaskType _type = null;
	private String _content = null;
	private Date _startDate = null;
	private Date _endDate = null;
	
	private boolean _isError = false;
	private String _errorMsg = null;
	
	public Result() {
		
	}
	
	public Result(int storageID, CommandType cmd, String content, 
			TaskType type, Date startDate, Date endDate) {
		this(content, startDate, endDate);
		_storageID = storageID;
		_cmd = cmd;
		_type = type;
	}
	
	public Result(String content, Date startDate, Date endDate) {
		_content = content;
		_startDate = startDate;
		_endDate = endDate;
	}
	
	public Result(CommandType cmd, Task task) {
		this(task.getTaskID(), cmd, task.getTaskName(),
				task.getTaskType(), task.getStartDate(), task.getEndDate());
	}
	
	/**
	 * Get storage ID.
	 * @return storage ID
	 */
	public int getStorageID() {
		return _storageID;
	}
	
	public void setStorageID(int ID) {
		_storageID = ID;
	}
	
	/**
	 * Get command.
	 * @return command
	 */
	public CommandType getCommand() {
		return _cmd;
	}
	
	public void setCommand(CommandType cmd) {
		_cmd = cmd;
	}
	
	/**
	 * Get content.
	 * @return title
	 */
	public String getContent() {
		return _content;
	}
	
	/**
	 * Set content. 
	 * @param content
	 */
	public void setContent(String content) {
		_content = content;
	}
	
	/**
	 * Get the type whether it is event, deadline or floating task.
	 * @return type 
	 */
	public TaskType getType() {
		return _type;
	}
	
	public void setType(TaskType taskType) {
		_type = taskType;
	}
	
	/**
	 * Get the start date and time of the event or deadline.
	 * @return startDate
	 */
	public Date getStartDate() {
		return _startDate;
	}
	
	/**
	 * Get the end date and time of the event or deadline.
	 * @return endDate
	 */
	public Date getEndDate() {
		return _endDate;
	}
	
	/**
	 * Set the start date and time of the event or deadline.
	 */
	public void setStartDate(Date startDate) {
		_startDate = startDate;
	}
	
	/**
	 * Set the start date and time of the event or deadline.
	 */
	public void setEndDate(Date endDate) {
		_endDate = endDate;
	}
	
	/**
	 * Set error message
	 * @param msg - error message
	 */
	public void setErrorMsg(String msg) {
		_isError = true;
		_errorMsg = msg;
	}
	
	/**
	 * Check if there is any parsing error.
	 * @return true if there is any error; false otherwise
	 */
	public boolean isError() {
		return _isError;
	}
	
	/**
	 * Get error message.
	 * @return error message
	 */
	public String getErrorMsg() {
		return _errorMsg;
	}
}
```
###### src\parser\IParseDateTime.java
``` java
public interface IParseDateTime {
	public static IParseDateTime getFunction(KeywordType keywordType, String input) {
		IParseDateTime function = null;
		
		switch (keywordType) {
			case AT: case IN: case ON: case FROM:
				function = new ParseEvent(input);
				break;
			case BY: case DUE:
				function = new ParseDeadline(input);
				break;
			default:
				function = new ParseDefault(input);
				break;
		}
		
		return function;
	}
	
	public DatePair analyze();
}
```
###### src\parser\ParseDeadline.java
``` java
public class ParseDeadline implements IParseDateTime {
	private static final String JOIN_DELIMITER = " ";
	private static final String SPLIT_DELIMITER = "\\s+";
	
	private String _input = null;

	public ParseDeadline(String input) {
		_input = input;
	}

	@Override
	public DatePair analyze() {
		ArrayList<String> words = new ArrayList<String>(Arrays.asList(_input.split(SPLIT_DELIMITER)));
		String input = _input;
		
		if (words.size() > 0) {
			KeywordType keyword = KeywordType.toType(words.get(0));
			
			if (keyword == KeywordType.DUE || keyword == KeywordType.BY) {
				words.remove(0);
				input = String.join(JOIN_DELIMITER, words);
			}
		}
		
		ParsedDate result = DateTime.parse(input);
		Date dateTime = result.getDate();
		String timeStr = DateTime.getTime(input);
		
		if (timeStr == null) {
			Date time = DateTime.parse("23:59").getDate();
			dateTime = DateTime.combineDateTime(dateTime, time);
		}
		
		Date now = new Date();
		if (dateTime != null && !result.isAbsolute() && dateTime.compareTo(now) < 0) {
			dateTime = DateTime.getOneYearLater(dateTime);
		}
		
		DatePair datePair = new DatePair(null, dateTime);
		
		if (dateTime != null) {
			datePair.setDateString(_input);
		}
		
		if (!result.isValid()) {
			datePair.setErrorMsg(ParserHelper.ERROR_INVALID_DATE);
		}
		
		return datePair;
	}

}
```
###### src\parser\ParseDefault.java
``` java
public class ParseDefault implements IParseDateTime {
	
	private String _input = null;
	
	public ParseDefault(String input) {
		_input = input;
	}

	@Override
	public DatePair analyze() {
		ParsedDate result = DateTime.parse(_input);
		Date startDate = result.getDate();
		Date endDate = null;
		String dateStr = result.getDateString();
		String timeStr = DateTime.getTime(_input);
		
		// If no time is given, set default event time from 8am to 11pm
		if (timeStr == null) {
			Date startTime = DateTime.parse("08:00").getDate();
			Date endTime = DateTime.parse("23:00").getDate();

			startDate = DateTime.combineDateTime(startDate, startTime);
			endDate = DateTime.combineDateTime(startDate, endTime);
		}
		
		if (isInteger(dateStr)) {
			startDate = null;
			endDate = null;
		}
	
		DatePair datePair = new DatePair(startDate, endDate);
		
		if (startDate != null) {
			datePair.setDateString(dateStr);
		}
		
		if (!result.isValid()) {
			datePair.setErrorMsg(ParserHelper.ERROR_INVALID_DATE);
		}
		
		return datePair;
	}
	
	/**
	 * Check if the input string is integer.
	 * @param input - possible integer string
	 * @return true if input is an integer; false otherwise
	 */
	private boolean isInteger(String input) {
		try {
			Integer.parseInt(input);
		} catch (NumberFormatException e) {
			return false;
		}
		return true;
	}

}
```
###### src\parser\ParseEvent.java
``` java
public class ParseEvent implements IParseDateTime {
	private static final String JOIN_DELIMITER = " ";
	private static final String SPLIT_DELIMITER = "\\s+";
	private static final String REPLACE_DELIMITER = "";
	
	private String _input = null;
	private final int _flags = Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE;
	private boolean _isAbsoluteDate = false;
	private boolean _isValidDate = false;

	public ParseEvent(String input) {
		_input = input;
	}

	@Override
	public DatePair analyze() {
		String timeStr = DateTime.getTime(_input);
		ParsedDate result = DateTime.parse(_input);
		Date startDate = result.getDate();
		Date endDate = null;
		
		_isAbsoluteDate = result.isAbsolute();
		_isValidDate = result.isValid();
		
		if (isFrom()) {
			DatePair pair = analyzeKeywordFrom();
			startDate = pair.getStartDate();
			endDate = pair.getEndDate();
		} 
		
		// If no time is given, set default event time from 8am to 11pm
		if (timeStr == null) {
			Date startTime = DateTime.parse("08:00").getDate();
			Date endTime = DateTime.parse("23:00").getDate();
			
			startDate = DateTime.combineDateTime(startDate, startTime);
			if (endDate != null) {
				endDate = DateTime.combineDateTime(endDate, endTime);
			} else {
				endDate = DateTime.combineDateTime(startDate, endTime);
			}
		}
		
		// If the entered date RANGE has passed, get the date(s) next year
		Date now = new Date();
		if (startDate != null && !_isAbsoluteDate && startDate.compareTo(now) < 0) {
			if (endDate != null && endDate.compareTo(now) < 0) {
				startDate = DateTime.getOneYearLater(startDate);
				endDate = DateTime.getOneYearLater(endDate);
			} else if (endDate == null) {
				startDate = DateTime.getOneYearLater(startDate);
			}
		}
		
		// Get the string contains date time format
		DatePair datePair = new DatePair(startDate, endDate);
		datePair.setDateString(getDateStr());
		
		if (!_isValidDate) {
			datePair.setErrorMsg(ParserHelper.ERROR_INVALID_DATE);
			System.out.println(datePair.isError());
		}
		
		return datePair;
	}
	
	/**
	 * Analyze the string that contains date or time format.
	 * @return date or time string
	 */
	private String getDateStr() {
		ArrayList<String> words = new ArrayList<>(Arrays.asList(_input.split(SPLIT_DELIMITER)));
		TreeMap<Integer, KeywordType> keywordIndices = ParserHelper.getKeywordIndex(words);
		ArrayList<Integer> indexList = new ArrayList<Integer>(keywordIndices.keySet());
		int listSize = indexList.size();
		String dateTimeStr = _input;
		
		for (int i = 0; i < listSize; i++) {
			int index = indexList.get(i);
			KeywordType type = keywordIndices.get(index);
			String keyword = type.toString();
			String impossibleStr = "";
			
			if (i < (listSize - 1)) {
				int nextIndex = indexList.get(i + 1);
				impossibleStr = String.join(JOIN_DELIMITER, words.subList(index, nextIndex));
			} else {
				impossibleStr = String.join(JOIN_DELIMITER, words.subList(index, words.size()));
			}
			
			ParsedDate result = DateTime.parse(impossibleStr);
			if (result.getDate() == null) {
				dateTimeStr = dateTimeStr.replace(impossibleStr, REPLACE_DELIMITER);
			} else {
				String joinStr = keyword + JOIN_DELIMITER + result.getDateString();

				if (!joinStr.equalsIgnoreCase(impossibleStr)) {
					dateTimeStr = result.getDateString();
				}
			}
		}
		
		// Reformat the string
		words = new ArrayList<>(Arrays.asList(dateTimeStr.split(SPLIT_DELIMITER)));
		dateTimeStr = String.join(JOIN_DELIMITER, dateTimeStr);
		
		return dateTimeStr;
	}
	
	/**
	 * Analyze string that begins with 'from'.
	 * @return start date and end date of parsing result
	 */
	private DatePair analyzeKeywordFrom() {
		Date startDate = null;
		Date endDate = null;
		int functionNo = 0;
		
		loop: while(true) {
			DatePair pair = new DatePair(null, null);
			
			switch(functionNo) {
				case 0:
					pair = analyzeFromToOn();
					break;
				case 1:
					pair = analyzeFromOn();
					break;
				case 2:
					pair = analyzeFrom();
					break;
				default:
					break loop;
			}
			
			if (pair.getStartDate() != null || pair.getEndDate() != null) {
				startDate = pair.getStartDate();
				endDate = pair.getEndDate();
				break loop;
			}
			
			functionNo += 1;
		}
		
		return new DatePair(startDate, endDate);
	}
	
	/**
	 * Analyze the string that begins with 'from' and contains 'to' and 'on'.
	 * @return start date and end date of parsing result
	 */
	private DatePair analyzeFromToOn() {
		String regexFromToOn = "from (.*?) to (.*) on (.*?)";
		Pattern pattern = Pattern.compile(regexFromToOn, _flags);
		Matcher matcher = pattern.matcher(_input);
		Date startDate = null;
		Date endDate = null;
		
		if (matcher.matches()) {
			Date startTime = DateTime.parse(matcher.group(1)).getDate();
			Date endTime = DateTime.parse(matcher.group(2)).getDate();
			
			ParsedDate dateResult = DateTime.parse(matcher.group(3));
			Date date = dateResult.getDate();

			//_isRelativeDate = DateTime.isRelativeDate(matcher.group(3));
			_isAbsoluteDate = dateResult.isAbsolute();
			_isValidDate = dateResult.isValid();
			
			if (startTime != null && date != null) {
				startDate = DateTime.combineDateTime(date, startTime);
			}
			
			if (endTime != null && date != null) {
				endDate = DateTime.combineDateTime(date, endTime);
			}
			
			if (startTime == null && endTime == null && date != null) {
				startDate = date;
			}
		}
		
		return new DatePair(startDate, endDate);
	}
	
	/**
	 * Analyze the string that begins with 'from' and contains 'on'.
	 * @return start date and end date of parsing result
	 */
	private DatePair analyzeFromOn() {
		String regexFromTo = "from (.*?) to (.*)";
		Pattern pattern = Pattern.compile(regexFromTo, _flags);
		Matcher matcher = pattern.matcher(_input);
		Date startDate = null;
		Date endDate = null;
		
		if (matcher.matches()) {
			ParsedDate startResult = DateTime.parse(matcher.group(1));
			ParsedDate endResult = DateTime.parse(matcher.group(2));
			startDate = startResult.getDate();
			endDate = endResult.getDate();
			
			_isAbsoluteDate = startResult.isAbsolute() || endResult.isAbsolute();
			_isValidDate = startResult.isValid() && endResult.isValid();
			
			if (endDate != null && startDate != null && 
					endDate.compareTo(startDate) < 0) {
				String[] startWords = matcher.group(1).split("\\s");
				String[] endWords = matcher.group(2).split("\\s");
				boolean isDayForStart = false;
				boolean isDayForEnd = false;
				
				for (int i = 0; i < startWords.length && !isDayForStart; i++) {
					if (DayType.toDay(startWords[i]) != DayType.INVALID) {
						isDayForStart = true;
					}
				}
				
				for (int i = 0; i < endWords.length && !isDayForEnd; i++) {
					if (DayType.toDay(endWords[i]) != DayType.INVALID) {
						isDayForEnd = true;
					}
				}
				
				if (isDayForStart && isDayForEnd) {
					endDate = DateTime.getOneWeekLater(endDate);
				}
			} else if (startDate == null && endDate != null) {
				startDate = endDate;
				endDate = null;
			}
		}
		return new DatePair(startDate, endDate);
	}
	
	/**
	 * Analyze the string that begins with 'from' only.
	 * @return start date and end date of parsing result
	 */
	private DatePair analyzeFrom() {
		String regexFrom = "from (.*?)";
		Pattern pattern = Pattern.compile(regexFrom, _flags);
		Matcher matcher = pattern.matcher(_input);
		Date startDate = null;
		
		if (matcher.matches()) {
			ParsedDate result = DateTime.parse(_input);
			startDate = result.getDate();
			_isAbsoluteDate = result.isAbsolute();
			_isValidDate = result.isValid();
		}
		
		return new DatePair(startDate, null);
	}
	
	/**
	 * Check if the first word is the keyword, 'from'.
	 * @return true if first word is 'from'; false otherwise
	 */
	private boolean isFrom() {
		String[] tokens = _input.split(SPLIT_DELIMITER);
		
		if (tokens.length > 0) {
			KeywordType keyword = KeywordType.toType(tokens[0]);
			
			if (keyword == KeywordType.FROM) {
				return true;
			}
		}
		return false;
	}
}
```
###### src\parser\Parser.java
``` java
public class Parser {
	private static final String JOIN_DELIMITER = " ";
	private static final String SPLIT_DELIMITER = "\\s+";
	private static final String REPLACE_DELIMITER = "";
	
	private static final Logger logger = Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);

	/**
	 * Parse the input string. 
	 * The result includes command type, corresponding taskID,
	 * content, task type, start date and end date. Any parsing
	 * error is included as well.
	 * @param input - input string
	 * @param displayList - display list
	 * @return the parsing result
	 */
	public static Result parse(String input, ArrayList<Task> displayList) {
		String[] splitWords = input.split(SPLIT_DELIMITER);
		ArrayList<String> words = new ArrayList<>(Arrays.asList(splitWords));
		
		Result result = new Result();
		CommandType cmd = analyzeCommand(words);
		int taskID = -1;
		String content = null;
		TaskType taskType = TaskType.INVALID;
		Date startDate = null;
		Date endDate = null;
		
		if (cmd != CommandType.INVALID) {
			words.remove(0);			// remove command from input string
			
			if (isIDNeeded(cmd)) {
				taskID = analyzeID(words, displayList);
				
				if (taskID == -1) {
					result.setErrorMsg(ParserHelper.ERROR_TASK_ID);
				}
				
				if (words.size() > 0 && isInteger(words.get(0))) {
					words.remove(0);
				}
			}
			
			ContentDate contentDate = analyzeContentDate(words);
			
			content = contentDate.getContent();
			startDate = contentDate.getStartDate();
			endDate = contentDate.getEndDate();
			
			if (contentDate.isError()) {
				result.setErrorMsg(contentDate.getErrorMsg());
			}
			
			taskType = analyzeTask(content, startDate, endDate);
			
		} else {
			content = input;
		}
		
		result.setCommand(cmd);
		result.setStorageID(taskID);
		result.setContent(content);
		result.setType(taskType);
		result.setStartDate(startDate);
		result.setEndDate(endDate);
		
		return result;
	}
	
	/**
	 * Check if getting of ID is need according to the input command.
	 * @param cmd - input command
	 * @return true if getting ID is need; false otherwise
	 */
	private static boolean isIDNeeded(CommandType cmd) {
		return cmd == CommandType.DELETE || 
				cmd == CommandType.EDIT ||
				cmd == CommandType.DONE ||
				cmd == CommandType.UNDONE;
	}
	
	/**
	 * Determine type of the command.
	 * @param words - words to be analyzed
	 * @return command type
	 */
	private static CommandType analyzeCommand(ArrayList<String> words) {
		if (words.size() > 0) {
			return CommandType.toCmd(words.get(0));
		}
		return CommandType.INVALID;
	}
	
	/**
	 * Determine the ID in storage corresponding to UI ID.
	 * @param words - words to be analyzed
	 * @param displayList - task list displayed in UI
	 * @return task ID in storage if exists; -1 otherwise
	 */
	private static int analyzeID(ArrayList<String> words, ArrayList<Task> displayList) {
		int taskID = -1;
		
		try {
			if (words.size() > 0) {
				int displayID = Integer.parseInt(words.get(0)) - 1;
				
				if (displayID >= 0 && displayID < displayList.size()) {
					taskID = displayList.get(displayID).getTaskID();
				}
			}
		} catch (NumberFormatException e) {
			logger.warning("Unable to retrieve task ID in storage.");
			return -1;
		}
		
		return taskID;
	}
	
	/**
	 * Determine the dates and title of the task.
	 * @param words - words to be analyzed
	 * @return title, start date and end date
	 */
	private static ContentDate analyzeContentDate(ArrayList<String> words) {
		TreeMap<Integer, KeywordType> keywordIndices = ParserHelper.getKeywordIndex(words);
		ArrayList<Integer> indexList = new ArrayList<Integer>(keywordIndices.keySet());
		int listSize = indexList.size();
		String content = String.join(" ", words);
		Date startDate = null;
		Date endDate = null;
		boolean isError = false;
		boolean isFound = false;
		String errorMsg = null;
		DatePair result = null;
		
		for (int i = 0; i < listSize; i++) {
			int index = indexList.get(i);
			KeywordType keyword = keywordIndices.get(index);
			String parseInput = "";
			isError = false;
			errorMsg = null;
			
			if (i < (listSize - 1)) {
				int nextIndex = indexList.get(i + 1);
				KeywordType nextKeyword = keywordIndices.get(nextIndex);
				
				// Include next keyword
				if (shouldInclude(nextKeyword)) {
					if ((i+1) < (listSize - 1)) {
						int nextNextIndex = indexList.get(i + 2);
						parseInput = String.join(JOIN_DELIMITER, words.subList(index, nextNextIndex));
					} else {
						parseInput = String.join(JOIN_DELIMITER, words.subList(index, words.size()));
					}
				} else {
					parseInput = String.join(JOIN_DELIMITER, words.subList(index, nextIndex));
				}
			} else {
				parseInput = String.join(JOIN_DELIMITER, words.subList(index, words.size()));
			}
			
			IParseDateTime function = IParseDateTime.getFunction(keyword, parseInput);
			result = function.analyze();
			
			// If date is found, remove the date time string from the input string
			if (isDateFound(result.getStartDate(), result.getEndDate())) {
				isFound = true;
				break;
			}
		}
		
		// If no keyword or date is not found, execute default parser type 
		if (indexList.isEmpty() || !isFound) {
			IParseDateTime function = IParseDateTime.getFunction(KeywordType.INVALID, content);
			result = function.analyze();
			
			if (isDateFound(result.getStartDate(), result.getEndDate())) {
				isFound = true;
			}
			
		}
		
		// Delete the date string from the given string
		if (isFound) {
			if (result.isError()) {
				isError = true;
				errorMsg = result.getErrorMsg();
			} else {
				String dateString = result.getDateString();
				startDate = result.getStartDate();
				endDate = result.getEndDate();
				content = String.join(" ", words);

				assert (dateString != null);

				content = content.replace(dateString, REPLACE_DELIMITER);

				String[] splitWords = content.split(SPLIT_DELIMITER);
				ArrayList<String> contentList = new ArrayList<>(Arrays.asList(splitWords));

				content = String.join(JOIN_DELIMITER, contentList);

				if (startDate != null && endDate != null) {
					if (startDate.compareTo(endDate) > 0) {
						isError = true;
						errorMsg = ParserHelper.ERROR_END_DATE_EARLIER;
					}
				}
			}
		}
		
		ContentDate contentDate = new ContentDate(content, startDate, endDate);
		
		if (isError) {
			contentDate.setErrorMsg(errorMsg);
		}
		
		return contentDate;
	}
	
	/**
	 * Check if the keyword should be included in the next sentence.
	 * @param keyword
	 * @return true if the keyword should be include; false otherwise
	 */
	private static boolean shouldInclude(KeywordType keyword) {
		return keyword == KeywordType.ON;
	}
	
	/**
	 * Check if any of start date or end date is found.
	 * @param startDate - start date
	 * @param endDate - end date
	 * @return true if any date is found; false otherwise
	 */
	private static boolean isDateFound(Date startDate, Date endDate) {
		if (startDate == null && endDate == null) {
			logger.info("Both the desired start and end date are not found.");
			return false;
		}
		return true;
	}
	
	/**
	 * Determine type of the task.
	 * @param title - title of the task
	 * @param startDate - start date and time
	 * @param endDate - end date and time
	 * @return task type
	 */
	private static TaskType analyzeTask(String title, Date startDate, Date endDate) {
		if (title == null || title.trim().isEmpty()) {
			return TaskType.INVALID;
		}
		
		if (startDate == null && endDate == null) {
			return TaskType.FLOATING;
		} else if (startDate == null && endDate != null) {
			return TaskType.DEADLINE;
		} else {
			return TaskType.EVENT;
		}
	}
	
	/**
	 * Check if the input string is integer.
	 * @param input - possible integer string
	 * @return true if input is an integer; false otherwise
	 */
	private static boolean isInteger(String input) {
		try {
			Integer.parseInt(input);
		} catch (NumberFormatException e) {
			return false;
		}
		return true;
	}
}
```
###### src\parser\ParserHelper.java
``` java
public class ParserHelper {
	public static final String ERROR_INVALID_COMMAND = "Feedback: The command entered does not exist!";
	public static final String ERROR_TASK_ID = "Feedback: The entered number does not exist!";
	public static final String ERROR_END_DATE_EARLIER = "Feedback: End date is earlier than start date!";
	public static final String ERROR_INVALID_DATE = "Feedback: The date entered is invalid!";
	
	public static TreeMap<Integer, KeywordType> getKeywordIndex(ArrayList<String> splitWords) {
		TreeMap<Integer, KeywordType> keywordIndex = new TreeMap<Integer, KeywordType>();
		boolean isConsecutive = false;
		for (int i = 0; i < splitWords.size(); i++) {
			String word = splitWords.get(i);
			KeywordType toType = KeywordType.toType(word);
			
			if (toType != KeywordType.INVALID && !isConsecutive) {
				keywordIndex.put(i, toType);
				isConsecutive = true;
			} else {
				isConsecutive = false;
			}
		}
		
		return keywordIndex;
	}
}
```
###### src\type\CommandType.java
``` java
public enum CommandType {
	ADD,
	EDIT,
	DELETE,
	SEARCH,
	SHOW,
	DONE,
	UNDONE,
	HELP,
	HOME,
	INVALID, 
	CAT, 
	MOVE;
	
	public static CommandType toCmd(String word) {
		try {
			word = word.toUpperCase();
			if (word.equals("DEL")) {
				return DELETE;
			}
			
			return valueOf(word); 
		} catch (Exception e) {
			return INVALID; 
		}
	}
}
```
###### src\type\DayType.java
``` java
public enum DayType {
	MONDAY,
	TUESDAY,
	WEDNESDAY,
	THURSDAY,
	FRIDAY,
	SATURDAY,
	SUNDAY,
	MON,
	TUE,
	TUES,
	WED,
	THU,
	THUR,
	THURS,
	FRI,
	SAT,
	SUN,
	INVALID;

	public static DayType toDay(String word) {
		try {
			word = word.toUpperCase();
			return valueOf(word); 
		} catch (Exception e) {
			return INVALID;
		}
	}
}
```
###### src\type\KeywordType.java
``` java
public enum KeywordType {
	AT,
	ON,
	FROM,
	IN,
	BY,
	DUE,
	INVALID;
	
	public static KeywordType toType(String word) {
		try {
			word = word.toUpperCase();	
			return valueOf(word); 
		} catch (Exception e) {
			return INVALID; 
		}
	}
}
```
###### src\type\MonthType.java
``` java
public enum MonthType {
	JAN,
	FEB,
	MAR,
	APR,
	MAY,
	JUN,
	JUL,
	AUG,
	SEP,
	OCT,
	NOV,
	DEC,
	JANUARY,
	FEBRUARY,
	MARCH,
	APRIL,
	JUNE,
	JULY,
	AUGUST,
	SEPTEMBER,
	OCTOBER,
	NOVEMBER,
	DECEMBER,
	INVALID;
	
	public static MonthType toMonth(String word) {
		try {
			word = word.toUpperCase();
			return valueOf(word); 
		} catch (Exception e) {
			return INVALID;
		}
	}
	
}
```
###### src\type\ShowType.java
``` java
public enum ShowType {
	ALL,
	DONE,
	UNDONE,
	INVALID;
	
	private static final Logger logger = Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);
	
	public static ShowType toType(String word) {
		try {
			word = word.toUpperCase();
			return valueOf(word); 
		} catch (Exception e) {
			logger.info("An invalid show type was specified.");
			return INVALID; 
		}
	}
}
```
###### src\type\TaskType.java
``` java
public enum TaskType {
	EVENT,
	DEADLINE,
	FLOATING,
	INVALID;
}
```
###### tests\date\DateTimeTest.java
``` java
public class DateTimeTest {
	
	private final static Logger logger = Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);

	@Test
	public void testSlashNumericDMY() {
		
		logger.info("Starting SlashNumericDMY test");

		SimpleDateFormat sdf = new SimpleDateFormat("dd MMM yyyy HH:mm");
		Calendar cal = Calendar.getInstance();
		
		cal.set(2015, 11, 16);
		String testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("16/12/2015").getDate()));
		
		cal.set(2015, 11, 17);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("17/12/15").getDate()));
		
		cal.set(2015, 11, 6);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("6/12/2015").getDate()));
		
		cal.set(2015, 11, 7);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("07/12/2015").getDate()));
		
		cal.set(2015, 1, 16);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("16/2/2015").getDate()));
		
		cal.set(2015, 1, 17);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("17/02/2015").getDate()));

		logger.info("Successful end of SlashNumericDMY test");
	}
	
	@Test 
	public void testHyphenNumericDMY() {
	    
	    logger.info("Starting HyphenNumericDMY test");

	    SimpleDateFormat sdf = new SimpleDateFormat("dd MMM yyyy HH:mm");
		Calendar cal = Calendar.getInstance();
		
		cal.set(2015, 11, 16);
		String testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("16-12-2015").getDate()));

		cal.set(2015, 11, 16);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("16-12-15").getDate()));

		cal.set(2015, 11, 6);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("6-12-2015").getDate()));

		cal.set(2015, 11, 6);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("06-12-2015").getDate()));

		cal.set(2015, 1, 16);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("16-2-2015").getDate()));

		cal.set(2015, 1, 16);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("16-02-2015").getDate()));

	    logger.info("Successful end of HyphenNumericDMY test");
	}
	
	@Test 
	public void testShortDMY() {
	    
		logger.info("Starting ShortDMY test");

	    SimpleDateFormat sdf = new SimpleDateFormat("dd MMM yyyy HH:mm");
		Calendar cal = Calendar.getInstance();
		
		cal.set(2015, 11, 16);
		String testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("16 Dec 2015").getDate()));

		cal.set(2015, 11, 16);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("16 Dec 15").getDate()));

		cal.set(2015, 11, 6);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("6 Dec 2015").getDate()));

		cal.set(2015, 11, 6);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("06 Dec 2015").getDate()));

		cal.set(2015, 1, 8);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("08 Feb 15").getDate()));

	    logger.info("Successful end of ShortDMY test");
	}
	
	@Test
	public void testSlashNumbericDM() {
	    
		logger.info("Starting SlashNumbericDM test");

	    SimpleDateFormat sdf = new SimpleDateFormat("dd MMM yyyy HH:mm");
		Calendar cal = Calendar.getInstance();
		
		cal.set(2015, 11, 16);
		String testDate = sdf.format(cal.getTime());
	    assertEquals(testDate, simpleFormat(DateTime.parse("16/12").getDate()));
	    
	    cal.set(2015, 11, 6);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("6/12").getDate()));
		
		cal.set(2015, 11, 6);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("06/12").getDate()));
		
		cal.set(2015, 1, 16);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("16/2").getDate()));
		
		cal.set(2015, 1, 16);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("16/02").getDate()));
	
	    logger.info("Successful end of SlashNumbericDM test");
	}
	
	@Test
	public void testHyphenNumbericDM() {
	    
		logger.info("Starting HyphenNumbericDM test");
		
		SimpleDateFormat sdf = new SimpleDateFormat("dd MMM yyyy HH:mm");
		Calendar cal = Calendar.getInstance();
		
		cal.set(2015, 11, 16);
		String testDate = sdf.format(cal.getTime());
	    assertEquals(testDate, simpleFormat(DateTime.parse("16-12").getDate()));

		cal.set(2015, 11, 6);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("6-12").getDate()));

		cal.set(2015, 11, 6);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("06-12").getDate()));

		cal.set(2015, 1, 16);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("16-2").getDate()));

		cal.set(2015, 1, 16);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("16-02").getDate()));

		logger.info("Successful end of HyphenNumbericDM test");
	}
	
	@Test 
	public void testShortDM() {
	    
		logger.info("Starting ShortDM test");

		SimpleDateFormat sdf = new SimpleDateFormat("dd MMM yyyy HH:mm");
		Calendar cal = Calendar.getInstance();
		
		cal.set(2015, 11, 16);
		String testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("16 Dec").getDate()));

		cal.set(2015, 11, 6);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("6 Dec").getDate()));

		cal.set(2015, 11, 6);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("06 Dec").getDate()));

		cal.set(2015, 1, 16);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("16 Feb").getDate()));
		
		logger.info("Successful end of ShortDM test");
	}
	
	@Test 
	public void testShortMD() {
	    
		logger.info("Starting ShortMD test");
		
		SimpleDateFormat sdf = new SimpleDateFormat("dd MMM yyyy HH:mm");
		Calendar cal = Calendar.getInstance();
		
		cal.set(2015, 11, 16);
		String testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("Dec 16").getDate()));
		
		cal.set(2015, 11, 6);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("Dec 6").getDate()));
		
		cal.set(2015, 11, 6);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("Dec 06").getDate()));
		
		cal.set(2015, 1, 16);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("Feb 16").getDate()));

		logger.info("Successful end of ShortMD test");
	}
	
	@Test
	public void testLongMD() {
		
		logger.info("Starting LongMD test");
		
		SimpleDateFormat sdf = new SimpleDateFormat("dd MMM yyyy HH:mm");
		Calendar cal = Calendar.getInstance();
		
		cal.set(2015, 11, 16);
		String testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("December 16").getDate()));
		
		cal.set(2015, 11, 6);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("December 6").getDate()));		
		
		cal.set(2015, 11, 6);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("December 06").getDate()));
		
		cal.set(2015, 1, 16);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("February 16").getDate()));
		
		logger.info("Successful end of LongMD test");

	}
	
	@Test 
	public void testTime() {
	    
		logger.info("Starting Time test");

	    assertEquals(getResult(0, 0, 0, 15, 0), simpleFormat(DateTime.parse("3pm").getDate()));
		assertEquals(getResult(0, 0, 0, 8, 0), simpleFormat(DateTime.parse("8am").getDate()));
		assertEquals(getResult(0, 0, 0, 17, 30), simpleFormat(DateTime.parse("17:30").getDate()));
		assertEquals(getResult(0, 0, 0, 17, 30), simpleFormat(DateTime.parse("17.30").getDate()));
		assertEquals(getResult(0, 0, 0, 17, 30), simpleFormat(DateTime.parse("5.30pm").getDate()));
		assertEquals(null, simpleFormat(DateTime.parse("25.30").getDate()));
	
		logger.info("Successful end of Time test");
	}
	
	@Test
	public void testMixture() {
	    
		logger.info("Starting Mixture test");
		
		SimpleDateFormat sdf = new SimpleDateFormat("dd MMM yyyy HH:mm");
		Calendar cal = Calendar.getInstance();
		
		cal.set(2015, 10, 4, 16, 0);
		String testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("Nov 4 4pm").getDate()));
		
		cal.set(2015, 1, 16, 7, 0);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("16 Feb 7am").getDate()));
		
		cal.set(2015, 10, 4, 8, 30);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("Nov 4 8.30").getDate()));
		
		cal.set(2015, 1, 16, 22, 10);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("16 Feb 22:10").getDate()));
		
		cal.set(2015, 1, 17, 22, 10);
		testDate = sdf.format(cal.getTime());
		assertEquals(testDate, simpleFormat(DateTime.parse("17 Feb 2015 22:10").getDate()));
	
	    logger.info("Successful end of Mixture test");
	}
	
	@Test
	public void testValidity(){
		
		logger.info("Starting Validity test");
		
		assertFalse(DateTime.parse("30 Feb").isValid());		// invalid day
		assertFalse(DateTime.parse("31 April").isValid());		// invalid day
		assertFalse(DateTime.parse("20/13/2015").isValid());	// invalid month
		assertFalse(DateTime.parse("20/-1/2015").isValid());	// invalid month
		assertFalse(DateTime.parse("29 Feb 2015").isValid());	// invalid leap year
		assertTrue(DateTime.parse("29 Feb 2016").isValid());	// valid leap year
		assertTrue(DateTime.parse("1 Jan").isValid());			// valid date
		assertTrue(DateTime.parse("31 Mar").isValid());			// valid date
		
		logger.info("Successful end of Validity test");
	}
	
	private String getResult(int year, int month, int date, int hour, int min) {
		Date currentTime = new Date();
		Calendar currentCalendar = Calendar.getInstance();
		Calendar givenCalendar = Calendar.getInstance();
		
		givenCalendar.clear();
		currentCalendar.setTime(currentTime);
		
		if (year == 0) {
			givenCalendar.set(Calendar.YEAR, currentCalendar.get(Calendar.YEAR));
		} else {
			givenCalendar.set(Calendar.YEAR, year);
		}
		
		if (month == 0) {
			givenCalendar.set(Calendar.MONTH, currentCalendar.get(Calendar.MONTH));
		} else {
			givenCalendar.set(Calendar.MONTH, month - 1);
		}
		
		if (date == 0) {
			givenCalendar.set(Calendar.DATE, currentCalendar.get(Calendar.DATE));
		} else {
			givenCalendar.set(Calendar.DATE, date);
		}
		
		givenCalendar.set(Calendar.HOUR_OF_DAY, hour);
		givenCalendar.set(Calendar.MINUTE, min);
		
		System.out.println(givenCalendar.getTime().toString());
		
		return simpleFormat(givenCalendar.getTime());
	}
	
	private String simpleFormat(Date date) {
		if (date == null) {
			return null;
		}
		DateFormat simpleDate = new SimpleDateFormat("dd MMM yyyy HH:mm");
		return simpleDate.format(date);
	}

}
```
